





<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Introduction to Relay IR &mdash; HHB 2.2 documentation</title>
  

  
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/tlcpack_theme.css" type="text/css" />

  
  

  
  
  
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <script type="text/javascript" src="../_static/js/tlcpack_theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    
<header class="header">
    <div class="innercontainer">
      <div class="headerInner d-flex justify-content-between align-items-center">
          <div class="headerLogo">
          </div>

          <div id="headMenu" class="headerNav">
            <button type="button" id="closeHeadMenu" class="navCloseBtn"><img src="../_static/img/close-icon.svg" alt="Close"></button>
             <ul class="nav">
                <li class="nav-item">
                   <a class="nav-link" href=https://www.yuque.com/za4k4z/oxlbxl>Docs</a>
                </li>
             </ul>
          </div>
          </div>
       </div>
    </div>
 </header>
 
    <nav data-toggle="wy-nav-shift" class="wy-nav-side fixed">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="sidetitle" alt="Documentation Home"> HHB
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Reference Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../reference/api/python/index.html">Python API</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      
      <nav class="wy-nav-top" aria-label="top navigation" data-toggle="wy-nav-top">
        
            <div class="togglemenu">

            </div>
            <div class="nav-content">
              <!-- HHB -->
              Table of content
            </div>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        

          




















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> <span class="br-arrow">></span></li>
        
      <li>Introduction to Relay IR</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/arch/relay_intro.rst.txt" rel="nofollow"> <img src="../_static//img/source.svg" alt="viewsource"/></a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="introduction-to-relay-ir">
<span id="relay-dev-intro"></span><h1>Introduction to Relay IR<a class="headerlink" href="#introduction-to-relay-ir" title="Permalink to this headline">¶</a></h1>
<p>This article introduces Relay IR – the second generation of NNVM.
We expect readers from two kinds of background – those who have a programming language background and deep learning
framework developers who are familiar with the computational graph representation.</p>
<p>We briefly summarize the design goal here, and will touch upon these points in the later part of the article.</p>
<ul class="simple">
<li><p>Support traditional data flow-style programming and transformations.</p></li>
<li><p>Support functional-style scoping, let-binding and making it a fully featured differentiable language.</p></li>
<li><p>Being able to allow the user to mix the two programming styles.</p></li>
</ul>
<div class="section" id="build-a-computational-graph-with-relay">
<h2>Build a Computational Graph with Relay<a class="headerlink" href="#build-a-computational-graph-with-relay" title="Permalink to this headline">¶</a></h2>
<p>Traditional deep learning frameworks use computational graphs as their intermediate representation.
A computational graph (or dataflow graph), is a directed acyclic graph (DAG) that represents the computation.
Though dataflow graphs are limited in terms of the computations they are capable of expressing due to
lacking control flow, their simplicity makes it easier to implement automatic differentiation and
compile for heterogeneous execution environments (e.g., executing parts of the graph on specialized hardware).</p>
<img alt="https://raw.githubusercontent.com/tvmai/tvmai.github.io/main/images/relay/dataflow.png" class="align-center" src="https://raw.githubusercontent.com/tvmai/tvmai.github.io/main/images/relay/dataflow.png" />
<p>You can use Relay to build a computational (dataflow) graph. Specifically, the above code shows how to
construct a simple two-node graph. You can find that the syntax of the example is not that different from existing
computational graph IR like NNVMv1, with the only difference in terms of terminology:</p>
<ul class="simple">
<li><p>Existing frameworks usually use graph and subgraph</p></li>
<li><p>Relay uses function e.g. –  <code class="docutils literal notranslate"><span class="pre">fn</span> <span class="pre">(%x)</span></code>, to indicate the graph</p></li>
</ul>
<p>Each dataflow node is a CallNode in Relay. The Relay Python DSL allows you to construct a dataflow graph quickly.
One thing we want to highlight in the above code – is that we explicitly constructed an Add node with
both input point to <code class="docutils literal notranslate"><span class="pre">%1</span></code>.  When a deep learning framework evaluates the above program, it will compute
the nodes in topological order, and <code class="docutils literal notranslate"><span class="pre">%1</span></code> will only be computed once.
While this fact is very natural to deep learning framework builders, it is something that might
surprise a PL researcher in the first place.  If we implement a simple visitor to print out the result and
treat the result as nested Call expression, it becomes <code class="docutils literal notranslate"><span class="pre">log(%x)</span> <span class="pre">+</span> <span class="pre">log(%x)</span></code>.</p>
<p>Such ambiguity is caused by different interpretations of program semantics when there is a shared node in the DAG.
In a normal functional programming IR, nested expressions are treated as expression trees, without considering the
fact that the <code class="docutils literal notranslate"><span class="pre">%1</span></code> is actually reused twice in <code class="docutils literal notranslate"><span class="pre">%2</span></code>.</p>
<p>The Relay IR is mindful of this difference. Usually, deep learning framework users build the computational
graph in this fashion, where a DAG node reuse often occurs. As a result, when we print out the Relay program in
the text format, we print one CallNode per line and assign a temporary id <code class="docutils literal notranslate"><span class="pre">(%1,</span> <span class="pre">%2)</span></code> to each CallNode so each common
node can be referenced in later parts of the program.</p>
</div>
<div class="section" id="module-support-multiple-functions-graphs">
<h2>Module: Support Multiple Functions (Graphs)<a class="headerlink" href="#module-support-multiple-functions-graphs" title="Permalink to this headline">¶</a></h2>
<p>So far we have introduced how can we build a dataflow graph as a function. One might naturally ask: Can we support multiple
functions and enable them to call each other? Relay allows grouping multiple functions together in a module; the code below
shows an example of a function calling another function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nd">@muladd</span><span class="p">(</span><span class="o">%</span><span class="n">x</span><span class="p">,</span> <span class="o">%</span><span class="n">y</span><span class="p">,</span> <span class="o">%</span><span class="n">z</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">%</span><span class="mi">1</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="o">%</span><span class="n">x</span><span class="p">,</span> <span class="o">%</span><span class="n">y</span><span class="p">)</span>
  <span class="o">%</span><span class="mi">2</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="o">%</span><span class="mi">1</span><span class="p">,</span> <span class="o">%</span><span class="n">z</span><span class="p">)</span>
  <span class="o">%</span><span class="mi">2</span>
<span class="p">}</span>
<span class="k">def</span> <span class="nd">@myfunc</span><span class="p">(</span><span class="o">%</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">%</span><span class="mi">1</span> <span class="o">=</span> <span class="nd">@muladd</span><span class="p">(</span><span class="o">%</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
  <span class="o">%</span><span class="mi">2</span> <span class="o">=</span> <span class="nd">@muladd</span><span class="p">(</span><span class="o">%</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
  <span class="o">%</span><span class="mi">2</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The Module can be viewed as a <code class="docutils literal notranslate"><span class="pre">Map&lt;GlobalVar,</span> <span class="pre">Function&gt;</span></code>. Here GlobalVar is just an id that is used to represent the functions
in the module. <code class="docutils literal notranslate"><span class="pre">&#64;muladd</span></code> and <code class="docutils literal notranslate"><span class="pre">&#64;myfunc</span></code> are GlobalVars in the above example. When a CallNode is used to call another function,
the corresponding GlobalVar is stored in the op field of the CallNode. It contains a level of indirection – we need to look up
body of the called function from the module using the corresponding GlobalVar. In this particular case, we could also directly
store the reference to the Function as op in the CallNode. So, why do we need to introduce GlobalVar? The main reason is that
GlobalVar decouples the definition/declaration and enables recursion and delayed declaration of the function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nd">@myfunc</span><span class="p">(</span><span class="o">%</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">%</span><span class="mi">1</span> <span class="o">=</span> <span class="n">equal</span><span class="p">(</span><span class="o">%</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
   <span class="k">if</span> <span class="p">(</span><span class="o">%</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">%</span><span class="n">x</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="o">%</span><span class="mi">2</span> <span class="o">=</span> <span class="n">sub</span><span class="p">(</span><span class="o">%</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
     <span class="o">%</span><span class="mi">3</span> <span class="o">=</span> <span class="nd">@myfunc</span><span class="p">(</span><span class="o">%</span><span class="mi">2</span><span class="p">)</span>
      <span class="o">%</span><span class="mi">4</span> <span class="o">=</span> <span class="n">add</span><span class="p">(</span><span class="o">%</span><span class="mi">3</span><span class="p">,</span> <span class="o">%</span><span class="mi">3</span><span class="p">)</span>
      <span class="o">%</span><span class="mi">4</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the above example, <code class="docutils literal notranslate"><span class="pre">&#64;myfunc</span></code> recursively calls itself. Using GlobalVar <code class="docutils literal notranslate"><span class="pre">&#64;myfunc</span></code> to represent the function avoids
the cyclic dependency in the data structure.
At this point, we have introduced the basic concepts in Relay. Notably, Relay has the following improvements over NNVMv1:</p>
<ul class="simple">
<li><p>Succinct text format that eases debugging of writing passes.</p></li>
<li><p>First-class support for subgraphs-functions, in a joint module, this enables further chance of joint optimizations such as inlining and calling convention specification.</p></li>
<li><p>Naive front-end language interop, for example, all the data structure can be visited in Python, which allows quick prototyping of optimizations in Python and mixing them with C++ code.</p></li>
</ul>
</div>
<div class="section" id="let-binding-and-scopes">
<h2>Let Binding and Scopes<a class="headerlink" href="#let-binding-and-scopes" title="Permalink to this headline">¶</a></h2>
<p>So far, we have introduced how to build a computational graph in the good old way used in deep learning frameworks.
This section will talk about a new important construct introduced by Relay – let bindings.</p>
<p>Let binding is used in every high-level programming language. In Relay, it is a data structure with three
fields <code class="docutils literal notranslate"><span class="pre">Let(var,</span> <span class="pre">value,</span> <span class="pre">body)</span></code>. When we evaluate a let expression, we first evaluate the value part, assign
it to the var, then return the evaluated result in the body expression.</p>
<p>You can use a sequence of let bindings to construct a logically equivalent program to a dataflow program.
The code example below shows one program with two forms side by side.</p>
<img alt="https://raw.githubusercontent.com/tvmai/tvmai.github.io/main/images/relay/dataflow_vs_func.png" class="align-center" src="https://raw.githubusercontent.com/tvmai/tvmai.github.io/main/images/relay/dataflow_vs_func.png" />
<p>The nested let binding is called A-normal form, and it is commonly used as IRs in functional programming languages.
Now, please take a close look at the AST structure. While the two programs are semantically identical
(so are their textual representations, except that A-normal form has let prefix), their AST structures are different.</p>
<p>Since program optimizations take these AST data structures and transform them, the two different structures will
affect the compiler code we are going to write. For example, if we want to detect a pattern <code class="docutils literal notranslate"><span class="pre">add(log(x),</span> <span class="pre">y)</span></code>:</p>
<ul class="simple">
<li><p>In the data-flow form, we can first access the add node, then directly look at its first argument to see if it is a log</p></li>
<li><p>In the A-normal form, we cannot directly do the check anymore, because the first input to add is <code class="docutils literal notranslate"><span class="pre">%v1</span></code> – we will need to keep a map from variable to its bound values and look up that map, in order to know that <code class="docutils literal notranslate"><span class="pre">%v1</span></code> is a log.</p></li>
</ul>
<p>Different data structures will impact how you might write transformations, and we need to keep that in mind.
So now, as a deep learning framework developer, you might ask, Why do we need let bindings?
Your PL friends will always tell you that let is important – as PL is a quite established field,
there must be some wisdom behind that.</p>
</div>
<div class="section" id="why-we-might-need-let-binding">
<h2>Why We Might Need Let Binding<a class="headerlink" href="#why-we-might-need-let-binding" title="Permalink to this headline">¶</a></h2>
<p>One key usage of let binding is that it specifies the scope of computation. Let us take a look at the following example,
which does not use let bindings.</p>
<img alt="https://raw.githubusercontent.com/tvmai/tvmai.github.io/main/images/relay/let_scope.png" class="align-center" src="https://raw.githubusercontent.com/tvmai/tvmai.github.io/main/images/relay/let_scope.png" />
<p>The problem comes when we try to decide where we should evaluate node <code class="docutils literal notranslate"><span class="pre">%1</span></code>. In particular, while the text format seems
to suggest that we should evaluate node <code class="docutils literal notranslate"><span class="pre">%1</span></code> outside the if scope, the AST(as shown in the picture) does not suggest so.
Actually, a dataflow graph never defines its scope of the evaluation. This introduces some ambiguity in the semantics.</p>
<p>This ambiguity becomes more interesting when we have closures. Consider the following program, which returns a closure.
We don’t know where should we compute <code class="docutils literal notranslate"><span class="pre">%1</span></code>; it can be either inside or outside the closure.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fn</span> <span class="p">(</span><span class="o">%</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="o">%</span><span class="mi">1</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="o">%</span><span class="n">x</span><span class="p">)</span>
  <span class="o">%</span><span class="mi">2</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span><span class="o">%</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">add</span><span class="p">(</span><span class="o">%</span><span class="n">y</span><span class="p">,</span> <span class="o">%</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="o">%</span><span class="mi">2</span>
<span class="p">}</span>
</pre></div>
</div>
<p>A let binding solves this problem, as the computation of the value happens at the let node. In both programs,
if we change <code class="docutils literal notranslate"><span class="pre">%1</span> <span class="pre">=</span> <span class="pre">log(%x)</span></code> to <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">%v1</span> <span class="pre">=</span> <span class="pre">log(%x)</span></code>, we clearly specify the computation location to
be outside of the if scope and closure. As you can see let-binding gives a more precise specification of the computation site
and could be useful when we generate backend code (as such specification is in the IR).</p>
<p>On the other hand, the dataflow form, which does not specify the scope of computation, does have its own advantages
– namely, we don’t need to worry about where to put the let when we generate the code. The dataflow form also gives more freedom
to the later passes to decide where to put the evaluation point. As a result, it might not be a bad idea to use data flow
form of the program in the initial phases of optimizations when you find it is convenient.
Many optimizations in Relay today are written to optimize dataflow programs.</p>
<p>However, when we lower the IR to an actual runtime program, we need to be precise about the scope of computation.
In particular, we want to explicitly specify where the scope of computation should happen when we are using
sub-functions and closures. Let-binding can be used to solve this problem in later stage execution specific optimizations.</p>
</div>
<div class="section" id="implication-on-ir-transformations">
<h2>Implication on IR Transformations<a class="headerlink" href="#implication-on-ir-transformations" title="Permalink to this headline">¶</a></h2>
<p>Hopefully, by now you are familiar with the two kinds of representations.
Most functional programming languages do their analysis in A-normal form,
where the analyzer does not need to be mindful that the expressions are DAGs.</p>
<p>Relay choose to support both the dataflow form and let bindings. We believe that it is important to let the
framework developer choose the representation they are familiar with.
This does, however, have some implications on how we write passes:</p>
<ul class="simple">
<li><p>If you come from a dataflow background and want to handle lets, keep a map of var to the expressions so you can perform lookup when encountering a var. This likely means a minimum change as we already need a map from expressions to transformed expressions anyway. Note that this will effectively remove all the lets in the program.</p></li>
<li><p>If you come from a PL background and like A-normal form, we will provide a dataflow to A-normal form pass.</p></li>
<li><p>For PL folks, when you are implementing something (like a dataflow-to-ANF transformation), be mindful that expressions can be DAGs, and this usually means that we should visit expressions with a <code class="docutils literal notranslate"><span class="pre">Map&lt;Expr,</span> <span class="pre">Result&gt;</span></code> and only compute the transformed result once, so the resulting expression keeps the common structure.</p></li>
</ul>
<p>There are additional advanced concepts such as symbolic shape inference, polymorphic functions
that are not covered by this material; you are more than welcome to look at other materials.</p>
</div>
</div>


           </div>
           
          </div>
          

<footer>

<div id="button" class="backtop"><img src="../_static//img/right.svg" alt="backtop"/> </div>
<section class="footerSec">
    <div class="footerHeader">
      <ul class="d-flex align-md-items-center justify-content-between flex-column flex-md-row">
        <li class="copywrite d-flex align-items-center">
          <h5 id="copy-right-info"></h5>
        </li>
      </ul>

    </div>

    <ul>
      <li class="footernote"></li>
    </ul>

</section>
</footer>
        </div>
      </div>

    </section>

  </div>
  

    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>

  </body>
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-75982049-2', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>